# 安全与性能优化方案

## 1. 安全方案

### 1.1 用户认证与授权

#### 1.1.1 JWT 认证机制
```
登录流程：
1. 用户提交用户名/邮箱 + 密码
2. 后端验证成功后生成 JWT Token
3. Token 包含：user_id, role, exp (过期时间)
4. 客户端存储 Token（localStorage/Cookie）
5. 后续请求在 Header 中携带 Token
```

**Token 设计**：
- **Access Token**：有效期 15 分钟（短期）
- **Refresh Token**：有效期 7 天（长期）
- 采用 RSA256 签名算法
- Payload 包含最小必要信息

**安全措施**：
- Token 存储在 HttpOnly Cookie（防 XSS）
- 启用 CSRF Token 保护
- Token 刷新机制（无感刷新）
- Token 黑名单（用户登出时失效）

---

#### 1.1.2 密码安全

**密码存储**：
```javascript
// 使用 bcrypt 加密密码
const bcrypt = require('bcrypt');
const saltRounds = 12; // 加盐轮数

// 注册时加密
const hashedPassword = await bcrypt.hash(plainPassword, saltRounds);

// 登录时验证
const isValid = await bcrypt.compare(plainPassword, hashedPassword);
```

**密码策略**：
- 最小长度：8 位
- 必须包含：大小写字母、数字、特殊字符
- 禁止常见弱密码（字典校验）
- 密码重置链接有效期：1 小时

---

#### 1.1.3 权限控制（RBAC）

**角色定义**：
| 角色 | 权限 |
|------|------|
| Guest | 浏览文章、查看评论 |
| User | Guest 权限 + 发表评论、点赞 |
| Admin | 全部权限（内容管理、用户管理） |

**权限中间件**：
```javascript
// 示例：检查管理员权限
function requireAdmin(req, res, next) {
  if (req.user.role !== 'admin') {
    return res.status(403).json({ error: '无权限访问' });
  }
  next();
}
```

---

### 1.2 输入验证与数据清洗

#### 1.2.1 前端验证
- 使用 Zod/Yup 进行 Schema 验证
- 实时验证（失焦触发）
- 友好的错误提示

#### 1.2.2 后端验证
```javascript
// 示例：文章创建验证
const articleSchema = {
  title: {
    type: 'string',
    minLength: 5,
    maxLength: 100,
    required: true
  },
  content: {
    type: 'string',
    minLength: 50,
    required: true
  },
  categoryId: {
    type: 'number',
    required: true
  }
};
```

#### 1.2.3 XSS 防护
- 对用户输入进行 HTML 转义
- 使用 DOMPurify 清洗 HTML
- Content Security Policy (CSP) 头部配置
- 禁止内联 JavaScript

**CSP 配置示例**：
```
Content-Security-Policy: 
  default-src 'self'; 
  script-src 'self' 'unsafe-inline' https://cdn.example.com;
  style-src 'self' 'unsafe-inline';
  img-src 'self' data: https:;
```

#### 1.2.4 SQL 注入防护
- 使用 ORM（Sequelize/Prisma/TypeORM）
- 参数化查询（Prepared Statements）
- 禁止拼接 SQL 语句

---

### 1.3 CSRF 防护

**实施方案**：
1. 生成 CSRF Token（服务端）
2. 将 Token 存入 Cookie（SameSite=Strict）
3. 前端在表单中携带 Token
4. 后端验证 Token 一致性

```javascript
// 后端生成 CSRF Token
const csrfToken = crypto.randomBytes(32).toString('hex');
res.cookie('csrf-token', csrfToken, { 
  httpOnly: false, 
  sameSite: 'strict' 
});

// 前端发送请求
fetch('/api/articles', {
  method: 'POST',
  headers: {
    'X-CSRF-Token': getCookie('csrf-token')
  },
  body: JSON.stringify(data)
});
```

---

### 1.4 API 安全

#### 1.4.1 限流策略（Rate Limiting）

**限流规则**：
| 接口类型 | 限制 | 说明 |
|---------|------|------|
| 登录/注册 | 5 次/分钟 | 防暴力破解 |
| 评论发表 | 10 次/分钟 | 防刷评论 |
| 文章浏览 | 100 次/分钟 | 防爬虫 |
| 搜索 | 30 次/分钟 | 防恶意搜索 |

**实现方案**：
```javascript
// 使用 express-rate-limit
const rateLimit = require('express-rate-limit');

const loginLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 分钟
  max: 5, // 最多 5 次
  message: '请求过于频繁，请稍后再试'
});

app.post('/api/auth/login', loginLimiter, loginHandler);
```

#### 1.4.2 API 签名验证（可选）
- 对关键接口启用签名验证
- 使用 HMAC-SHA256 算法
- 防止中间人攻击

---

### 1.5 文件上传安全

**安全措施**：
1. **文件类型验证**：仅允许图片（jpg, png, webp）
2. **文件大小限制**：单个文件不超过 5MB
3. **文件名随机化**：UUID 命名，避免路径遍历
4. **病毒扫描**：集成 ClamAV（可选）
5. **存储隔离**：上传文件存储在独立目录，禁止执行权限

```javascript
// 文件上传配置
const multer = require('multer');

const storage = multer.diskStorage({
  destination: 'uploads/',
  filename: (req, file, cb) => {
    const uuid = crypto.randomUUID();
    const ext = path.extname(file.originalname);
    cb(null, `${uuid}${ext}`);
  }
});

const upload = multer({
  storage,
  limits: { fileSize: 5 * 1024 * 1024 }, // 5MB
  fileFilter: (req, file, cb) => {
    const allowedTypes = ['image/jpeg', 'image/png', 'image/webp'];
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('不支持的文件类型'));
    }
  }
});
```

---

### 1.6 HTTPS 与数据传输安全

**必备措施**：
- 强制 HTTPS（HTTP 自动跳转）
- TLS 1.2+ 加密协议
- HSTS 头部配置（强制 HTTPS）
- 证书自动续期（Let's Encrypt）

```
Strict-Transport-Security: max-age=31536000; includeSubDomains
```

---

### 1.7 敏感信息保护

**环境变量管理**：
```env
# .env 文件（不提交到 Git）
DATABASE_URL=postgresql://user:password@localhost:5432/blog
JWT_SECRET=your-super-secret-key
SMTP_PASSWORD=email-password
OSS_ACCESS_KEY=oss-access-key
OSS_SECRET_KEY=oss-secret-key
```

**安全存储**：
- 生产环境使用密钥管理服务（AWS Secrets Manager / HashiCorp Vault）
- 定期轮换密钥
- 日志脱敏（不记录密码、Token）

---

### 1.8 安全日志与监控

**日志记录**：
- 登录成功/失败记录（IP、时间、User-Agent）
- 权限拒绝事件
- 异常操作（批量删除、频繁修改）

**告警机制**：
- 短时间内多次登录失败 → 邮件/短信告警
- IP 黑名单自动封禁（5 分钟内登录失败 5 次）

---

## 2. 性能优化方案

### 2.1 数据库优化

#### 2.1.1 索引优化

**核心索引**：
```sql
-- 文章表
CREATE INDEX idx_articles_status ON articles(status);
CREATE INDEX idx_articles_category ON articles(category_id);
CREATE INDEX idx_articles_created ON articles(created_at DESC);
CREATE INDEX idx_articles_views ON articles(view_count DESC);

-- 复合索引（分类 + 状态 + 发布时间）
CREATE INDEX idx_articles_category_status_created 
ON articles(category_id, status, created_at DESC);

-- 全文搜索索引
CREATE INDEX idx_articles_fulltext ON articles USING GIN(to_tsvector('english', title || ' ' || content));

-- 评论表
CREATE INDEX idx_comments_article ON comments(article_id);
CREATE INDEX idx_comments_user ON comments(user_id);
CREATE INDEX idx_comments_status ON comments(status);
```

#### 2.1.2 查询优化

**慢查询监控**：
- 启用 PostgreSQL 慢查询日志（> 500ms）
- 使用 EXPLAIN ANALYZE 分析查询计划
- 避免 N+1 查询（使用 JOIN 或 DataLoader）

**分页优化**：
```sql
-- 避免使用 OFFSET（大偏移量性能差）
-- 推荐使用游标分页
SELECT * FROM articles 
WHERE id > last_id 
ORDER BY id ASC 
LIMIT 20;
```

#### 2.1.3 连接池配置

```javascript
// PostgreSQL 连接池
const pool = new Pool({
  max: 20, // 最大连接数
  min: 5,  // 最小连接数
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000
});
```

---

### 2.2 缓存策略

#### 2.2.1 Redis 缓存

**缓存层级**：
```
客户端浏览器 → CDN → Redis → 数据库
```

**缓存内容**：
| 数据类型 | 缓存时间 | 说明 |
|---------|---------|------|
| 首页文章列表 | 5 分钟 | 高频访问 |
| 文章详情 | 30 分钟 | 更新频率低 |
| 分类/标签列表 | 1 小时 | 变化少 |
| 热门文章排行 | 10 分钟 | 需定期更新 |
| 用户信息 | 15 分钟 | 会话期间 |

**缓存策略**：
```javascript
// 示例：文章详情缓存
async function getArticle(slug) {
  const cacheKey = `article:${slug}`;
  
  // 1. 尝试从缓存获取
  const cached = await redis.get(cacheKey);
  if (cached) {
    return JSON.parse(cached);
  }
  
  // 2. 缓存未命中，查询数据库
  const article = await db.articles.findOne({ slug });
  
  // 3. 写入缓存
  await redis.setex(cacheKey, 1800, JSON.stringify(article)); // 30 分钟
  
  return article;
}
```

**缓存失效策略**：
- 主动失效：文章更新/删除时清除缓存
- 被动失效：设置 TTL 自动过期
- 缓存预热：系统启动时预加载热门数据

---

#### 2.2.2 HTTP 缓存

**静态资源缓存**：
```nginx
# Nginx 配置
location ~* \.(js|css|png|jpg|jpeg|gif|webp|svg|woff|woff2)$ {
  expires 1y;
  add_header Cache-Control "public, immutable";
}
```

**API 响应缓存**：
```
Cache-Control: public, max-age=300  # 5 分钟
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
```

---

### 2.3 图片优化

#### 2.3.1 图片压缩与格式转换

**方案**：
1. 上传时自动压缩（Sharp 库）
2. 生成多种尺寸（缩略图、中图、原图）
3. WebP 格式优先（兼容性降级）

```javascript
const sharp = require('sharp');

async function processImage(inputPath) {
  const outputPath = `${inputPath}-compressed.webp`;
  
  await sharp(inputPath)
    .resize(1200, null, { withoutEnlargement: true })
    .webp({ quality: 80 })
    .toFile(outputPath);
  
  return outputPath;
}
```

**响应式图片**：
```html
<picture>
  <source srcset="image-small.webp" media="(max-width: 600px)" type="image/webp">
  <source srcset="image-medium.webp" media="(max-width: 1200px)" type="image/webp">
  <img src="image-large.jpg" alt="封面图" loading="lazy">
</picture>
```

#### 2.3.2 懒加载

```javascript
// 使用 Intersection Observer API
const imageObserver = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const img = entry.target;
      img.src = img.dataset.src;
      imageObserver.unobserve(img);
    }
  });
});

document.querySelectorAll('img[data-src]').forEach(img => {
  imageObserver.observe(img);
});
```

---

### 2.4 CDN 加速

**CDN 部署方案**：
- **静态资源**：JS/CSS/图片 → CDN
- **API 接口**：保持原服务器
- **地域覆盖**：国内 CDN（阿里云/腾讯云）+ 国际 CDN（Cloudflare）

**配置示例**：
```nginx
# Nginx 反向代理 CDN
location /static/ {
  proxy_pass https://cdn.example.com;
  proxy_cache_valid 200 1d;
}
```

---

### 2.5 前端性能优化

#### 2.5.1 代码分割与懒加载

```javascript
// Next.js 动态导入
const DynamicComponent = dynamic(() => import('./HeavyComponent'), {
  loading: () => <p>Loading...</p>,
  ssr: false
});
```

#### 2.5.2 资源打包优化

**Webpack/Vite 配置**：
- Tree Shaking（移除未使用代码）
- 代码压缩（Terser）
- Gzip/Brotli 压缩
- Bundle 分析（webpack-bundle-analyzer）

**优化目标**：
- 首屏加载时间 < 2 秒
- 首次内容绘制（FCP）< 1.5 秒
- 最大内容绘制（LCP）< 2.5 秒

#### 2.5.3 预加载与预连接

```html
<!-- DNS 预解析 -->
<link rel="dns-prefetch" href="https://cdn.example.com">

<!-- 预连接 -->
<link rel="preconnect" href="https://api.example.com">

<!-- 预加载关键资源 -->
<link rel="preload" href="/fonts/font.woff2" as="font" crossorigin>
```

---

### 2.6 SSR/SSG 优化（Next.js）

**渲染策略**：
| 页面类型 | 渲染方式 | 说明 |
|---------|---------|------|
| 首页 | ISR（增量静态生成） | 每 60 秒重新验证 |
| 文章详情 | SSG + Fallback | 静态生成 + 按需生成 |
| 分类/标签 | SSR | 实时数据 |
| 用户中心 | CSR（客户端渲染） | 个性化内容 |

**ISR 配置**：
```javascript
export async function getStaticProps() {
  const articles = await fetchArticles();
  
  return {
    props: { articles },
    revalidate: 60 // 60 秒后重新生成
  };
}
```

---

### 2.7 数据库读写分离

**架构**：
```
写操作 → 主数据库（Master）
读操作 → 从数据库（Slave）
```

**实现方案**：
```javascript
// Sequelize 配置
const sequelize = new Sequelize({
  replication: {
    read: [
      { host: 'slave1.example.com', username: 'read', password: '...' },
      { host: 'slave2.example.com', username: 'read', password: '...' }
    ],
    write: { host: 'master.example.com', username: 'write', password: '...' }
  }
});
```

---

### 2.8 监控与日志

#### 2.8.1 性能监控

**监控指标**：
- API 响应时间（P50, P95, P99）
- 数据库查询时间
- 缓存命中率
- 错误率
- QPS（每秒请求数）

**工具推荐**：
- **后端**：Prometheus + Grafana
- **前端**：Google Analytics + Lighthouse
- **APM**：New Relic / Datadog（可选）

#### 2.8.2 日志管理

**日志分级**：
- ERROR：错误日志（需要立即处理）
- WARN：警告日志
- INFO：信息日志
- DEBUG：调试日志（仅开发环境）

**日志聚合**：
- ELK Stack（Elasticsearch + Logstash + Kibana）
- 或使用云服务（阿里云日志服务）

---

## 3. 部署与运维

### 3.1 自动化部署（CI/CD）

**GitHub Actions 示例**：
```yaml
name: Deploy to Production

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '18'
      
      - name: Install Dependencies
        run: npm ci
      
      - name: Run Tests
        run: npm test
      
      - name: Build
        run: npm run build
      
      - name: Deploy to Server
        run: |
          scp -r build/* user@server:/var/www/blog
          ssh user@server "pm2 reload blog"
```

---

### 3.2 容器化部署（Docker）

**Dockerfile 示例**：
```dockerfile
FROM node:18-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

FROM node:18-alpine
WORKDIR /app
COPY --from=builder /app/.next ./.next
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package.json ./package.json

EXPOSE 3000
CMD ["npm", "start"]
```

**Docker Compose**：
```yaml
version: '3.8'
services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - DATABASE_URL=${DATABASE_URL}
      - REDIS_URL=${REDIS_URL}
  
  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: blog
      POSTGRES_PASSWORD: ${DB_PASSWORD}
  
  redis:
    image: redis:7-alpine
```

---

### 3.3 备份策略

**数据库备份**：
- 全量备份：每天凌晨 2 点
- 增量备份：每 6 小时
- 保留周期：30 天
- 异地备份：备份文件同步到云存储（S3/OSS）

**自动备份脚本**：
```bash
#!/bin/bash
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="/backups"
pg_dump blog > $BACKUP_DIR/blog_$DATE.sql
gzip $BACKUP_DIR/blog_$DATE.sql

# 上传到 OSS
ossutil cp $BACKUP_DIR/blog_$DATE.sql.gz oss://my-bucket/backups/
```

---

## 4. 性能优化检查清单

### 4.1 前端优化
- [ ] 启用 Gzip/Brotli 压缩
- [ ] 图片懒加载
- [ ] 代码分割（Code Splitting）
- [ ] 资源预加载（Preload/Prefetch）
- [ ] 使用 CDN 加速
- [ ] 减少 HTTP 请求
- [ ] 使用现代图片格式（WebP）
- [ ] 首屏渲染优化（SSR/SSG）

### 4.2 后端优化
- [ ] 数据库索引优化
- [ ] Redis 缓存热点数据
- [ ] API 限流
- [ ] 数据库连接池
- [ ] 读写分离
- [ ] 慢查询监控

### 4.3 安全检查
- [ ] HTTPS 强制跳转
- [ ] JWT Token 认证
- [ ] 密码加密存储
- [ ] XSS/CSRF 防护
- [ ] SQL 注入防护
- [ ] 文件上传安全
- [ ] 敏感信息加密
- [ ] 日志脱敏

---

## 5. 下一步行动

✅ **架构规划已全部完成**，包括：
1. ✅ 技术架构方案设计
2. ✅ 数据库模型设计
3. ✅ RESTful API 接口设计
4. ✅ 用户旅程地图（User Roadmap）
5. ✅ 站点地图（Site Map）
6. ✅ 前台页面线框图设计
7. ✅ 后台管理系统线框图设计
8. ✅ 安全与性能优化方案

**接下来可以开始开发实施**：
- 初始化项目（Next.js + NestJS）
- 数据库表创建与迁移
- 实现核心 API 接口
- 前端组件开发
- 部署上线与测试
